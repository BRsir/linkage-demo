<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四杆机构教学演示系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .animated-pulse {
            animation: pulse 2s infinite;
        }
        /* 修复二维码容器居中问题 */
        #qrcode img {
            margin: 0 auto;
        }
    </style>
</head>
<body class="bg-slate-50 font-sans">
    <div class="max-w-7xl mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-800 mb-2">四杆机构教学演示系统</h1>
            <p class="text-slate-600">调节机架长度，观察不同类型四杆机构的运动特性</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold text-slate-700 mb-4 border-b pb-2">机构参数设置</h2>
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-slate-600 mb-2">固定参数</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="bg-slate-50 p-3 rounded"><span class="text-slate-500">主动连架杆：</span><span class="font-medium">90mm</span></div>
                        <div class="bg-slate-50 p-3 rounded"><span class="text-slate-500">从动连架杆：</span><span class="font-medium">150mm</span></div>
                        <div class="bg-slate-50 p-3 rounded col-span-2"><span class="text-slate-500">连杆：</span><span class="font-medium">210mm</span></div>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-sm font-medium text-slate-600 mb-2">机架长度调节 (10-280mm)</h3>
                    <div class="flex flex-col gap-3">
                        <input type="range" id="frameLength" min="10" max="280" value="120" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                        <div class="flex items-center justify-between">
                            <span id="frameValue" class="text-lg font-medium text-slate-800">120 mm</span>
                            <button id="resetBtn" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition">重置</button>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-sm font-medium text-slate-600 mb-2">当前机构类型</h3>
                    <div id="mechanismType" class="bg-green-50 p-4 rounded-lg text-center text-lg font-semibold text-green-700 animated-pulse">曲柄摇杆机构</div>
                </div>

                <div>
                    <h3 class="text-sm font-medium text-slate-600 mb-2">运动控制</h3>
                    <div class="flex gap-3">
                        <button id="playBtn" class="flex-1 bg-emerald-500 text-white px-4 py-2 rounded hover:bg-emerald-600 transition">开始运动</button>
                        <button id="pauseBtn" class="flex-1 bg-amber-500 text-white px-4 py-2 rounded hover:bg-amber-600 transition">暂停运动</button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-lg shadow-md p-6 flex flex-col items-center justify-center">
                <h2 class="text-xl font-semibold text-slate-700 mb-4">机构运动演示</h2>
                <div class="relative">
                    <canvas id="mechanismCanvas" width="400" height="400" class="border border-slate-200 rounded-lg"></canvas>
                    <div class="absolute bottom-2 left-1/2 -translate-x-1/2 text-xs text-slate-500 w-full text-center">
                        红色：主动杆 | 蓝色：连杆 | 绿色：从动杆
                    </div>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 flex flex-col items-center justify-center">
                <h2 class="text-xl font-semibold text-slate-700 mb-4 text-center">学生互动二维码</h2>
                
                <div id="qrcode" class="mb-4 border border-slate-200 rounded-lg p-2 bg-white flex items-center justify-center" style="width: 180px; height: 180px;"></div>
                
                <div class="text-center text-slate-600">
                    <p class="mb-2 font-medium" id="qrTextStatus">扫码链接已生成</p>
                    <p class="text-sm text-slate-500">可在移动端查看机构运动演示</p>
                </div>
            </div>
        </div>

        <footer class="mt-8 text-center text-slate-500 text-sm">
            <p>四杆机构类型判断依据：格拉霍夫定理（Grashof's Law）| 教学演示专用</p>
        </footer>
    </div>

    <script>
        // 全局变量
        let frameLength = 120;
        let isPlaying = true;
        let animationId = null;
        let angle = 0;
        let ctx = null;
        let canvas = null;
        let qrcodeObj = null; // 存储二维码对象

        const a = 90; const b = 210; const c = 150; 
        const scale = 1; const centerX = 200; const centerY = 200; 
        let track1 = []; let track2 = []; 

        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('mechanismCanvas');
            ctx = canvas.getContext('2d');
            const frameSlider = document.getElementById('frameLength');
            const frameValue = document.getElementById('frameValue');
            const resetBtn = document.getElementById('resetBtn');
            const playBtn = document.getElementById('playBtn');
            const pauseBtn = document.getElementById('pauseBtn');

            // 1. 读取URL参数
            const urlParams = new URLSearchParams(window.location.search);
            const paramFrame = urlParams.get('frame');
            if (paramFrame) {
                frameLength = parseInt(paramFrame);
                frameSlider.value = frameLength;
                frameValue.textContent = `${frameLength} mm`;
            }

            // 2. 初始化
            updateMechanismType();
            // 延时一点点生成二维码，确保DOM完全就绪
            setTimeout(() => updateQRCode(frameLength), 100);
            drawMechanism();
            animate();

            // 3. 事件监听
            frameSlider.addEventListener('input', (e) => {
                frameLength = parseInt(e.target.value);
                frameValue.textContent = `${frameLength} mm`;
                updateMechanismType();
                
                // 防抖动：拖动结束再更新二维码，避免卡顿，但这里为了演示实时更新
                updateQRCode(frameLength); 
                
                track1 = []; track2 = []; drawMechanism();
            });

            resetBtn.addEventListener('click', () => {
                frameLength = 120;
                frameSlider.value = 120;
                frameValue.textContent = `${frameLength} mm`;
                updateMechanismType();
                updateQRCode(frameLength);
                track1 = []; track2 = []; angle = 0; drawMechanism();
            });

            playBtn.addEventListener('click', () => {
                if (!isPlaying) { isPlaying = true; animate(); }
            });

            pauseBtn.addEventListener('click', () => {
                isPlaying = false;
                if (animationId) cancelAnimationFrame(animationId);
            });
        });

        // --- 核心修复：更稳定的二维码生成逻辑 ---
        function updateQRCode(length) {
            const qrContainer = document.getElementById('qrcode');
            const statusText = document.getElementById('qrTextStatus');
            const baseUrl = window.location.href.split('?')[0];
            const content = `${baseUrl}?frame=${length}`;

            // 检查库是否加载成功
            if (typeof QRCode === 'undefined') {
                statusText.innerText = "正在加载组件...";
                statusText.style.color = "red";
                return;
            }

            statusText.innerText = "扫码体验移动端";
            statusText.style.color = "#4b5563";

            // 如果对象已存在，直接清空并重新生成
            // 注意：BootCDN 的 qrcode.js 使用 innerHTML 清空法最稳妥
            qrContainer.innerHTML = ""; 
            
            try {
                new QRCode(qrContainer, {
                    text: content,
                    width: 160,
                    height: 160,
                    colorDark : "#000000",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.M
                });
            } catch (e) {
                console.error("二维码生成出错:", e);
                statusText.innerText = "生成失败，请刷新";
            }
        }

        function updateMechanismType() {
            const typeElement = document.getElementById('mechanismType');
            const d = frameLength;
            const shortest = Math.min(a, b, c, d);
            const longest = Math.max(a, b, c, d);
            const sumMinMax = shortest + longest;
            const sumRest = (a + b + c + d) - sumMinMax;

            let type = '';
            let style = 'bg-green-50 text-green-700';

            if (sumMinMax <= sumRest) {
                if (shortest === a) {
                    type = (shortest === d) ? '双曲柄机构' : '曲柄摇杆机构';
                    if(shortest === d) style = 'bg-blue-50 text-blue-700';
                } else if (shortest === d) {
                    type = '双曲柄机构';
                    style = 'bg-blue-50 text-blue-700';
                } else if (shortest === c) {
                    type = '曲柄摇杆机构';
                } else {
                    type = (d === longest) ? '曲柄摇杆机构' : '双摇杆机构';
                    if(type === '双摇杆机构') style = 'bg-purple-50 text-purple-700';
                }
            } else {
                type = '无法构成机构 (死点/断开)';
                style = 'bg-red-50 text-red-700';
            }
            typeElement.textContent = type;
            typeElement.className = `${style} p-4 rounded-lg text-center text-lg font-semibold animated-pulse`;
        }

        function drawMechanism() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const A = { x: centerX - frameLength * scale / 2, y: centerY };
            const D = { x: centerX + frameLength * scale / 2, y: centerY };
            const B = { x: A.x + a * scale * Math.cos(angle), y: A.y + a * scale * Math.sin(angle) };

            const dx = D.x - B.x; const dy = D.y - B.y;
            const distBD = Math.sqrt(dx * dx + dy * dy);

            // 物理约束检查
            if (distBD > b + c || distBD < Math.abs(b - c)) {
                // 如果构不成三角形，只画部分
                drawNode(A); drawNode(D); drawNode(B);
                drawLine(A, B, '#ef4444', 4);
                drawLine(A, D, '#1e293b', 4);
                return; 
            }

            const cosTheta = (c*c + distBD*distBD - b*b) / (2 * c * distBD);
            const theta = Math.acos(Math.max(-1, Math.min(1, cosTheta)));
            const phi = Math.atan2(dy, dx);
            const C = { x: D.x - c * Math.cos(phi + theta), y: D.y - c * Math.sin(phi + theta) };

            track1.push(B); track2.push(C);
            if (track1.length > 200) track1.shift();
            if (track2.length > 200) track2.shift();

            drawPath(track1, 'rgba(239, 68, 68, 0.4)');
            drawPath(track2, 'rgba(59, 130, 246, 0.4)');
            drawLine(A, D, '#1e293b', 4); drawLine(A, B, '#ef4444', 4);
            drawLine(B, C, '#3b82f6', 4); drawLine(C, D, '#22c55e', 4);
            drawNode(A); drawNode(D); drawNode(B); drawNode(C);
        }

        function drawLine(p1, p2, color, w) {
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color; ctx.lineWidth = w; ctx.stroke();
        }
        function drawPath(points, color) {
            if(points.length < 2) return;
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.moveTo(points[0].x, points[0].y);
            for(let p of points) ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }
        function drawNode(p) {
            ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
            ctx.fillStyle = '#000'; ctx.fill();
        }
        function animate() {
            if (isPlaying) {
                angle += 0.04;
                drawMechanism();
                animationId = requestAnimationFrame(animate);
            }
        }
    </script>
</body>
</html>
